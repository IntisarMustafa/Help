<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ (MobileNetV2) ÙˆØ§Ù„ØµÙˆØª Ø§Ù„Ù…Ø­Ø³Ù‘Ù†</title>
    <!-- ØªØ­Ù…ÙŠÙ„ Ù…ÙƒØªØ¨Ø§Øª TensorFlow.js Ùˆ COCO-SSD -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- COCO-SSD Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ù„ØªØ­Ù…ÙŠÙ„ backbone MobileNetV2 Ø¨Ø´ÙƒÙ„ ØµØ±ÙŠØ­ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        /* Ø¥Ø¶Ø§ÙØ© Ø®Ø·ÙˆØ· Ø¹Ø±Ø¨ÙŠØ© Ø¬Ù…ÙŠÙ„Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© */
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Cairo', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f1c4e, #2a417e); /* ØªØ¯Ø±Ø¬ Ù„ÙˆÙ†ÙŠ Ø£Ø¹Ù…Ù‚ */
            color: white;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-weight: 700;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .app-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        
        .video-section, .info-section {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            /* ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ø¨ÙˆØ§Ø³Ø·Ø© JS Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© (Ù„Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ´ÙˆÙ‡) */
            padding-bottom: 0; 
            min-height: 250px; /* Ø§Ø±ØªÙØ§Ø¹ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #videoElement, #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙŠÙ…Ù„Ø£ Ø§Ù„Ø­Ø§ÙˆÙŠØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø³Ø¨Ø© */
            object-fit: contain; 
        }

        /* ØªØµØ­ÙŠØ­ Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³: Ù†Ø¹ÙƒØ³ ÙÙ‚Ø· Ø§Ù„Ù€ Canvas Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù…Ù†Ø¸ÙˆØ± Ø§Ù„Ù…Ø±Ø¢Ø© Ù„Ù„Ø±Ø³Ù… */
        #canvasElement {
            transform: scaleX(-1);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-weight: bold;
        }
        
        button:hover {
            background: #357abd;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        #startBtn {
            background: #28a745;
        }
        
        #startBtn:hover:not(:disabled) {
            background: #218838;
        }
        
        #stopBtn {
            background: #dc3545;
        }
        
        #stopBtn:hover:not(:disabled) {
            background: #c82333;
        }
        
        #speakBtn {
            background: #6f42c1;
        }
        
        #speakBtn:hover:not(:disabled) {
            background: #5a359c;
        }
        
        .results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            min-height: 150px;
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .result-item {
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-right: 4px solid #fdbb2d; /* Ù„ÙˆÙ† Ù…Ù…ÙŠØ² */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-item strong {
            font-size: 1.1rem;
        }
        
        .result-item .confidence {
            font-size: 0.9rem;
            opacity: 0.8;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px 8px;
            border-radius: 5px;
        }
        
        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
            transition: background 0.3s ease;
        }
        
        .status.ready {
            background: rgba(40, 167, 69, 0.3);
        }
        
        .status.processing {
            background: rgba(255, 193, 7, 0.3);
        }
        
        .status.error {
            background: rgba(220, 53, 69, 0.3);
        }
        
        .status.warning { /* ØªØµÙ…ÙŠÙ… Ø¬Ø¯ÙŠØ¯ Ù„Ù„ØªØ­Ø°ÙŠØ± */
            background: rgba(255, 165, 0, 0.3);
            color: #fff;
        }
        
        .statistics {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .statistics p {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
            padding-bottom: 5px;
        }
        
        .statistics p:last-child {
            border-bottom: none;
        }
        
        .instructions {
            margin-top: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .instructions h2 {
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        .instructions ol {
            padding-right: 20px;
            list-style-type: decimal-leading-zero;
        }
        
        .instructions li {
            margin-bottom: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .audio-controls, .settings-row {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: space-between;
        }
        
        .audio-controls label {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-basis: 48%; /* Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø¹Ù„Ù‰ Ø³Ø·Ø±ÙŠÙ† ÙÙŠ Ø´Ø§Ø´Ø§Øª Ø§Ù„Ø¬ÙˆØ§Ù„ */
            min-width: 150px;
            justify-content: space-between;
        }
        
        .settings {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }
        
        .settings h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .settings-item {
            flex: 1;
            min-width: 150px;
        }
        
        .settings-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .settings-item select, .settings-item input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .settings-item select {
            appearance: none;
            background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill="%234A90E2" d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>');
            background-repeat: no-repeat;
            background-position: left 10px center;
            padding-left: 30px; /* Ù„ØªØ±Ùƒ Ù…Ø³Ø§Ø­Ø© Ù„Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© */
        }
        
        .empty-results {
            text-align: center;
            opacity: 0.7;
            padding: 20px;
        }
        
        .detection-counter {
            display: inline-block;
            background: #fdbb2d;
            color: #0f1c4e;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            text-align: center;
            line-height: 28px;
            font-size: 1rem;
            margin-right: 5px;
            font-weight: bold;
        }
        
        .tts-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #fdbb2d;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .controls, .audio-controls, .settings-row {
                flex-direction: column;
            }
            
            button, .audio-controls label, .settings-item {
                width: 100%;
                min-width: unset;
            }
            
            .audio-controls label {
                flex-basis: 100%;
                justify-content: space-between;
            }
        }
        
        .icon {
            font-size: 1.2rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ‘ï¸ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙƒØ´Ù Ø§Ù„Ø°ÙƒÙŠ Ø¹Ù† Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ (MobileNetV2)</h1>
            <p class="subtitle">ÙŠØ³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù†Ù…ÙˆØ°Ø¬ **MobileNetV2** Ø¹Ø§Ù„ÙŠ Ø§Ù„ÙƒÙØ§Ø¡Ø© Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ØŒ Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙÙˆØ±ÙŠØ© ÙˆØ§Ù„ØªØ¹Ù„ÙŠÙ‚ Ø§Ù„ØµÙˆØªÙŠ Ø¨ÙˆØ§Ø³Ø·Ø© Gemini.</p>
        </header>
        
        <div class="app-container">
            <section class="video-section">
                <h2>Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© ÙˆØ§Ù„ÙƒØ´Ù</h2>
                <div class="video-container" id="videoContainer">
                    <video id="videoElement" autoplay playsinline></video>
                    <canvas id="canvasElement"></canvas>
                </div>
                
                <div class="controls">
                    <button id="startBtn">
                        <span class="icon">â–¶ï¸</span>
                        Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù
                    </button>
                    <button id="stopBtn" disabled>
                        <span class="icon">â¹ï¸</span>
                        Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ´Ù
                    </button>
                    <button id="speakBtn" disabled>
                        <span class="icon">ğŸ”Š</span>
                        ØªÙƒØ±Ø§Ø± Ø§Ù„ÙƒØ´Ù
                    </button>
                </div>
                
                <div class="settings">
                    <h3>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙˆØª ÙˆØ§Ù„ÙƒØ´Ù</h3>
                    <!-- Ø¹Ù†ØµØ± Ù…Ø´ØºÙ„ Ø§Ù„ØµÙˆØª Ø§Ù„Ù…Ø®ÙÙŠ Ù„Ù€ Gemini TTS -->
                    <audio id="audioPlayer" style="display: none;"></audio>
                    <div id="ttsStatus" class="mt-2 text-center text-xs text-white flex justify-center items-center"></div>

                    <div class="audio-controls">
                        <label>
                            Ø§Ù„ØªØ­Ø¯Ø« ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                            <input type="checkbox" id="autoSpeak" checked>
                        </label>
                        <!-- Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª ÙŠØªØ­ÙƒÙ… ÙÙŠ Ù…Ø´ØºÙ„ Ø§Ù„ØµÙˆØª HTML5 Ø§Ù„Ø¢Ù† -->
                        <label>
                            Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª
                            <input type="range" id="volumeControl" min="0" max="1" step="0.1" value="0.9">
                        </label>
                    </div>
                    
                    <div class="settings-row">
                        <div class="settings-item">
                            <label for="detectionInterval">ÙØªØ±Ø© Ø§Ù„ÙƒØ´Ù (Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ)</label>
                            <select id="detectionInterval">
                                <option value="1">1 Ø«Ø§Ù†ÙŠØ©</option>
                                <option value="2" selected>2 Ø«Ø§Ù†ÙŠØ©</option>
                                <option value="3">3 Ø«ÙˆØ§Ù†ÙŠ</option>
                                <option value="4">4 Ø«ÙˆØ§Ù†ÙŠ</option>
                            </select>
                        </div>
                        <div class="settings-item">
                            <label for="confidenceThreshold">Ø­Ø¯ Ø§Ù„Ø«Ù‚Ø© (%)</label>
                            <select id="confidenceThreshold">
                                <option value="0.5" selected>50%</option>
                                <option value="0.6">60%</option>
                                <option value="0.7">70%</option>
                                <option value="0.8">80%</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="status processing" id="status">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...</div>
            </section>
            
            <section class="info-section">
                <h2>Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„Ù…ÙƒØªØ´ÙØ© (<span id="objectsCount" class="detection-counter">0</span>)</h2>
                <div class="results" id="results">
                    <p class="empty-results">Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£ÙŠ Ø£Ø´ÙŠØ§Ø¡ Ø¨Ø¹Ø¯. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù" Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©.</p>
                </div>
                
                <div class="statistics">
                    <h3>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡</h3>
                    <p>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©: <span id="totalDetections">0</span></p>
                    <p>Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: <span id="lastUpdate">--</span></p>
                    <p>Ù…Ø¹Ø¯Ù„ Ø§Ù„ÙƒØ´Ù: <span id="detectionRate">--</span></p>
                </div>
            </section>
        </div>
        
        <section class="instructions">
            <h2>ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚</h2>
            <ol>
                <li>Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± **"Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù"**. Ø³ÙŠÙ‚ÙˆÙ… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø·Ù„Ø¨ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ© (Ù„ØªÙˆÙÙŠØ± Ø¯Ù‚Ø© Ø£Ø¹Ù„Ù‰).</li>
                <li>ÙˆØ¬Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù†Ø­Ùˆ Ø§Ù„Ø£Ø´ÙŠØ§Ø¡Ø› Ø³ÙŠÙ‚ÙˆÙ… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨ØªØ­Ø¯ÙŠØ¯Ù‡Ø§ ÙˆØ±Ø³Ù… Ù…Ø±Ø¨Ø¹ Ø­ÙˆÙ„Ù‡Ø§.</li>
                <li>**Ù†Ø¸Ø§Ù… Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±:** Ø³ÙŠØªÙ… Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† Ø¹Ù† Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ ØµÙˆØªÙŠØ§Ù‹ **Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©** ÙÙ‚Ø·ØŒ ÙˆÙ„Ù† ÙŠØªØ­Ø¯Ø« Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ØªØºÙŠØ± Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø£Ùˆ Ø¨Ø¹Ø¯ Ù…Ø±ÙˆØ± Ø«Ù„Ø§Ø« Ø¯ÙˆØ±Ø§Øª ÙƒØ´Ù.</li>
                <li>**Ø§Ù„ÙƒØ´Ù Ø§Ù„ÙØ¹Ø§Ù„:** ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù†Ù…ÙˆØ°Ø¬ MobileNetV2 Ø¹Ø§Ù„ÙŠ Ø§Ù„ÙƒÙØ§Ø¡Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ø±Ø¹Ø© Ø¬ÙŠØ¯Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙƒØ´Ù.</li>
                <li>**Ø§Ù„ØµÙˆØª ÙˆØ§Ù„ØªØ±Ø¬Ù…Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Gemini:** ÙŠØªÙ… ØªØ±Ø¬Ù…Ø© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ù…ÙˆØ°Ø¬ GeminiØŒ ÙˆÙŠØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙƒÙ„Ø§Ù… Ø¹Ø§Ù„ÙŠ Ø§Ù„Ø¬ÙˆØ¯Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ù…ÙˆØ°Ø¬ **Gemini TTS**.</li>
                <li>Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± **"ØªÙƒØ±Ø§Ø± Ø§Ù„ÙƒØ´Ù"** Ù„Ø³Ù…Ø§Ø¹ Ø¢Ø®Ø± Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.</li>
            </ol>
        </section>
        
        <footer>
            <p>ØªÙ… ØªØ·ÙˆÙŠØ± Ù‡Ø°Ø§ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… TensorFlow.js ÙˆÙ†Ù…ÙˆØ°Ø¬ MobileNetV2 Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ ÙˆØªØ±Ø¬Ù…Ø© Gemini ÙˆØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini TTS.</p>
            <p>Â© 2023 ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ù„Ù„Ù…ÙƒÙÙˆÙÙŠÙ† - ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„ØµÙˆØª ÙˆØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±.</p>
        </footer>
    </div>

    <script>
        // ======================================================================
        // Ù…ØªØºÙŠØ±Ø§Øª LLM Ùˆ TTS
        // ======================================================================
        const API_KEY = ""; // Ø³ÙŠØªÙ… ØªÙˆÙÙŠØ±Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙÙŠ Ø¨ÙŠØ¦Ø© Canvas
        // Ø¹Ù†Ø§ÙˆÙŠÙ† URL Ù„Ù†Ù…Ø§Ø°Ø¬ Gemini
        const GEMINI_TRANSLATION_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=" + API_KEY;
        const TTS_MODEL_NAME = "gemini-2.5-flash-preview-tts";
        const GEMINI_TTS_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL_NAME}:generateContent?key=${API_KEY}`;
        
        // Ù…ÙˆØ¬Ù‡ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ±Ø¬Ù…Ø©
        const TRANSLATION_SYSTEM_PROMPT = "You are a professional translator. Translate the given English object class name into a single, concise Arabic word or phrase, suitable for reading aloud. Respond with ONLY the translated Arabic text, without any explanation or punctuation like quotes.";
        let translationCache = {}; // ØªØ®Ø²ÙŠÙ† Ù…Ø¤Ù‚Øª Ù„Ù„ØªØ±Ø¬Ù…Ø§Øª Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª Ø§Ù„Ù…ØªÙƒØ±Ø±Ø©

        // ======================================================================
        // ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù€ API Ùˆ PCM Ø¥Ù„Ù‰ WAV (Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù€ Gemini TTS)
        // ======================================================================

        // ØªØ­ÙˆÙŠÙ„ Base64 Ø¥Ù„Ù‰ ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // ØªØ­ÙˆÙŠÙ„ PCM Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ WAV (Ù…Ø·Ù„ÙˆØ¨ Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª Ø§Ù„Ø®Ø§Ù… ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­)
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM (Int16Array)
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcm16.length * bytesPerSample;

            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            let offset = 0;

            function writeString(str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset++, str.charCodeAt(i));
                }
            }
            function writeUint32(val) {
                view.setUint32(offset, val, true); offset += 4;
            }
            function writeUint16(val) {
                view.setUint16(offset, val, true); offset += 2;
            }

            // RIFF chunk descriptor
            writeString('RIFF');
            writeUint32(36 + dataSize);
            writeString('WAVE');

            // fmt sub-chunk
            writeString('fmt ');
            writeUint32(16); // Sub-chunk size
            writeUint16(1);  // Audio format (1 for PCM)
            writeUint16(numChannels);
            writeUint32(sampleRate);
            writeUint32(byteRate);
            writeUint16(blockAlign);
            writeUint16(bytesPerSample * 8); // Bits per sample (16)

            // data sub-chunk
            writeString('data');
            writeUint32(dataSize);

            // PCM data
            const pcm8 = new Uint8Array(buffer, 44);
            const pcmData = new Uint8Array(pcm16.buffer);
            pcm8.set(pcmData);

            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        // ÙˆØ¸ÙŠÙØ© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù€ API (Exponential Backoff)
        async function fetchWithExponentialBackoff(url, options, maxRetries = 5) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        return await response.json();
                    }
                    if (response.status === 429 && attempt < maxRetries - 1) {
                        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw new Error(`API response failed: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    if (attempt === maxRetries - 1) {
                        throw error;
                    }
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        // ======================================================================
        // ÙˆØ¸ÙŠÙØ© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø°ÙƒÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini
        // ======================================================================
        async function translateWithGemini(englishText) {
            const key = englishText.toLowerCase().trim();
            if (translationCache[key]) {
                return translationCache[key];
            }

            const payload = {
                contents: [{ parts: [{ text: `Translate "${englishText}" to Arabic.` }] }],
                systemInstruction: {
                    parts: [{ text: TRANSLATION_SYSTEM_PROMPT }]
                },
            };

            try {
                const result = await fetchWithExponentialBackoff(GEMINI_TRANSLATION_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const translatedText = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || englishText;
                const cleanText = translatedText.replace(/['"â€œâ€]/g, '').split('\n')[0].trim();

                translationCache[key] = cleanText;
                return cleanText;

            } catch (error) {
                console.error(`Gemini Translation Error for ${englishText}:`, error);
                return englishText;
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù„ØªØ±Ø¬Ù…Ø© Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ø¦Ù†
        async function translateObjectName(name) {
            return await translateWithGemini(name);
        }

        // ======================================================================
        // ÙˆØ¸ÙŠÙØ© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini TTS
        // ======================================================================

        let isSpeaking = false; // Ù„Ù…Ù†Ø¹ ØªØ¯Ø§Ø®Ù„ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø·Ù‚
        
        async function speakText(text) {
            if (isSpeaking) {
                 console.log("TTS busy, skipping current utterance.");
                 return; 
            }
            
            isSpeaking = true;
            ttsStatus.innerHTML = '<div class="tts-spinner"></div> Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª...';

            const payload = {
                contents: [{
                    parts: [{ text: text }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            // Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØª Ø¹Ø±Ø¨ÙŠ Ù…Ù†Ø§Ø³Ø¨
                            prebuiltVoiceConfig: { voiceName: "Orus" } 
                        }
                    }
                },
            };
            
            try {
                const result = await fetchWithExponentialBackoff(GEMINI_TTS_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    audioPlayer.src = audioUrl;
                    audioPlayer.volume = parseFloat(volumeControl.value); // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª
                    audioPlayer.load();
                    audioPlayer.play();
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„Ù†Ø·Ù‚
                    audioPlayer.onended = () => {
                        isSpeaking = false;
                        ttsStatus.textContent = 'Ø§Ù„ØµÙˆØª Ø¬Ø§Ù‡Ø².';
                        URL.revokeObjectURL(audioUrl); // ØªØ­Ø±ÙŠØ± Ø§Ù„Ø°Ø§ÙƒØ±Ø©
                    };
                    audioPlayer.onerror = (e) => {
                        console.error('Audio playback error:', e);
                        isSpeaking = false;
                        ttsStatus.textContent = 'Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª.';
                        URL.revokeObjectURL(audioUrl); 
                    };
                    
                } else {
                    throw new Error("ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØª Ù…Ù† Ø§Ø³ØªØ¬Ø§Ø¨Ø© API.");
                }

            } catch (error) {
                console.error("Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ ØµÙˆØª Gemini TTS:", error);
                isSpeaking = false;
                ttsStatus.textContent = 'Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª. ' + (error.message || 'Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„.');
            }
        }


        // Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙÙŠ Ø§Ù„ØµÙØ­Ø©
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const videoContainer = document.getElementById('videoContainer');
        const canvasContext = canvasElement.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const speakBtn = document.getElementById('speakBtn');
        const statusDiv = document.getElementById('status');
        const resultsDiv = document.getElementById('results');
        const objectsCountSpan = document.getElementById('objectsCount');
        const totalDetectionsSpan = document.getElementById('totalDetections');
        const lastUpdateSpan = document.getElementById('lastUpdate');
        const detectionRateSpan = document.getElementById('detectionRate');
        const autoSpeakCheckbox = document.getElementById('autoSpeak');
        const volumeControl = document.getElementById('volumeControl');
        const detectionIntervalSelect = document.getElementById('detectionInterval');
        const confidenceThresholdSelect = document.getElementById('confidenceThreshold');
        const audioPlayer = document.getElementById('audioPlayer');
        const ttsStatus = document.getElementById('ttsStatus');
        
        // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
        let model = null;
        let isDetecting = false;
        let detectionInterval = null;
        let lastDetections = []; 
        let stream = null;
        let totalDetections = 0;
        let detectionStartTime = null;
        let detectionCount = 0;
        
        // Ù…ØªØºÙŠØ±Ø§Øª Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± (Debouncing)
        let lastSpokenObjects = ''; 
        const CHATTER_THRESHOLD = 3; 
        let sameObjectsCounter = 0;

        
        // ----------------------------------------------------------------------
        // ÙˆØ¸Ø§Ø¦Ù ØªÙ‡ÙŠØ¦Ø© ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø­Ø§Ù„Ø©
        // ----------------------------------------------------------------------
        
        function updateStatusDisplay() {
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¬Ø§Ù‡Ø²ÙŠØ© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
            if (model) {
                statusDiv.textContent = 'Ù†Ù…ÙˆØ°Ø¬ MobileNetV2 Ø¬Ø§Ù‡Ø² - Ø§Ø¶ØºØ· "Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù"';
                statusDiv.className = 'status ready';
                speakBtn.disabled = false;
                ttsStatus.textContent = 'Ø®Ø¯Ù…Ø© Ø§Ù„ØµÙˆØª (Gemini TTS) Ø¬Ø§Ù‡Ø²Ø©.';
            } else {
                statusDiv.textContent = 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ MobileNetV2...';
                statusDiv.className = 'status processing';
                speakBtn.disabled = true;
                ttsStatus.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù†ØªØ¸Ø§Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬...';
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¶Ø¨Ø· Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„Ø­Ø§ÙˆÙŠØ©
        function setVideoAndCanvasDimensions() {
            if (videoElement.videoWidth && videoElement.videoHeight) {
                const aspectRatio = videoElement.videoHeight / videoElement.videoWidth;
                
                // ØªØ­Ø¯ÙŠØ« Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ù€ Canvas
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø­Ø§ÙˆÙŠØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¹Ø±Ø¶ Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
                const containerWidth = videoContainer.offsetWidth;
                videoContainer.style.height = `${containerWidth * aspectRatio}px`;
                videoContainer.style.paddingBottom = '0'; 
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        async function initCamera() {
            try {
                statusDiv.textContent = 'Ø¬Ø§Ø±ÙŠ Ø·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...';
                statusDiv.className = 'status processing';
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment', // ØªÙØ¶ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ© Ù„Ù„Ø¬ÙˆØ§Ù„
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                videoElement.srcObject = stream;
                
                await new Promise((resolve, reject) => {
                    videoElement.onloadedmetadata = () => {
                        setVideoAndCanvasDimensions();
                        if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
                            reject(new Error("Ø¯ÙÙ‚ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙØ´Ù„ ÙÙŠ ØªÙˆÙÙŠØ± Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ØµØ­ÙŠØ­Ø© (0x0)."));
                            return;
                        }
                        videoElement.play().then(resolve).catch(e => {
                            console.warn("ÙØ´Ù„ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ:", e);
                            resolve(); 
                        });
                    };
                    setTimeout(() => {
                         if (!videoElement.srcObject) { 
                            reject(new Error("Video stream failed to load metadata in time."));
                         } else if (videoElement.readyState < 2) {
                             resolve();
                         }
                    }, 5000);
                });
                
                window.addEventListener('resize', setVideoAndCanvasDimensions);
                statusDiv.textContent = 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ø¹Ù…Ù„.';
                return true;
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:', error);
                let errorMessage = 'Ø®Ø·Ø£: ÙØ´Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§. ';
                if (error.name === 'NotAllowedError' || error.message.includes('permission')) {
                    errorMessage += 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† **Ù…Ù†Ø­ Ø§Ù„Ø¥Ø°Ù†** Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.';
                } else {
                    errorMessage += `[${error.name || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}]`;
                }

                statusDiv.textContent = errorMessage;
                statusDiv.className = 'status error';
                startBtn.disabled = false;
                stopBtn.disabled = true;
                return false;
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        async function loadModel() {
            try {
                statusDiv.textContent = 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ MobileNetV2...';
                statusDiv.className = 'status processing';
                
                // *** Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ: ØªØ­Ù…ÙŠÙ„ MobileNetV2 Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø£ÙØ¶Ù„ ÙˆØ£ÙƒØ«Ø± Ø­Ø¯Ø§Ø«Ø© ***
                const modelConfig = { 
                    base: 'mobilenet_v2', 
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø³Ø§Ø± Ù†Ù…ÙˆØ°Ø¬ MobileNetV2 Ø§Ù„Ø±Ø³Ù…ÙŠ Ù„Ù€ COCO-SSD
                    modelUrl: 'https://storage.googleapis.com/tfjs-models/savedmodel/ssd_mobilenet_v2/model.json' 
                };
                
                model = await cocoSsd.load(modelConfig);
                
                updateStatusDisplay(); 
                
                return true;
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬:', error);
                statusDiv.textContent = 'Ø®Ø·Ø£: ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ MobileNetV2.';
                statusDiv.className = 'status error';
                startBtn.disabled = true;
                return false;
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø£Ø´ÙŠØ§Ø¡
        async function detectObjects() {
            if (!model || !isDetecting) return;

            if (videoElement.readyState < 2) { 
                if (statusDiv.className !== 'status processing') {
                    statusDiv.textContent = 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„Ù… ØªØ­Ù…Ù„ Ø¥Ø·Ø§Ø±Ù‹Ø§ Ø¨Ø¹Ø¯ØŒ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...';
                    statusDiv.className = 'status processing';
                }
                return;
            }
            
            try {
                const confidenceThreshold = parseFloat(confidenceThresholdSelect.value);
                
                if (!videoElement.srcObject || videoElement.paused || videoElement.ended) {
                     stopDetection();
                     return;
                }
                
                const predictions = await model.detect(videoElement);
                
                const filteredPredictions = predictions.filter(p => p.score >= confidenceThreshold);
                
                // 1. ØªØ±Ø¬Ù…Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ© Ø¯ÙØ¹Ø© ÙˆØ§Ø­Ø¯Ø© (Ù…Ù‡Ù…: ÙŠØ¬Ø¨ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ±Ø¬Ù…Ø©)
                const translatedPredictions = await Promise.all(filteredPredictions.map(async p => ({
                    ...p,
                    translatedClass: await translateObjectName(p.class)
                })));

                updateResults(translatedPredictions);
                
                lastUpdateSpan.textContent = new Date().toLocaleTimeString('ar-SA');
                updateStatistics(translatedPredictions);

                // Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ø§Ù‡Ø²Ø©
                if (statusDiv.className === 'status processing') { 
                    statusDiv.textContent = 'Ø§Ù„ÙƒØ´Ù Ù…Ø³ØªÙ…Ø±.';
                    statusDiv.className = 'status ready';
                }
                
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙƒØ´Ù:', error);
                statusDiv.textContent = 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙƒØ´Ù.';
                statusDiv.className = 'status error';
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© (Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ Ø§Ù„ØªØ­Ø¯Ø«)
        function updateResults(predictions) {
            resultsDiv.innerHTML = '';
            objectsCountSpan.textContent = predictions.length;
            
            if (predictions.length === 0) {
                resultsDiv.innerHTML = '<p class="empty-results">Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£ÙŠ Ø£Ø´ÙŠØ§Ø¡ ÙÙŠ Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ.</p>';
                lastDetections = [];
                drawDetections([]); // Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ù…
                
                if (lastSpokenObjects !== '') {
                    sameObjectsCounter = 0; 
                    lastSpokenObjects = ''; 
                }
                
                return;
            }
            
            lastDetections = predictions;

            const uniqueObjects = [...new Set(lastDetections.map(p => p.translatedClass))];
            
            predictions.forEach(prediction => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                
                const confidencePercent = (prediction.score * 100).toFixed(1);
                resultItem.innerHTML = `
                    <strong>${prediction.translatedClass}</strong>
                    <span class="confidence">${confidencePercent}%</span>
                `;
                
                resultsDiv.appendChild(resultItem);
            });
            
            // --- Ù…ÙŠØ²Ø© Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± (Debouncing) ---
            const currentObjectsString = uniqueObjects.sort().join(', '); 
            
            let shouldSpeak = false;

            if (currentObjectsString !== lastSpokenObjects) {
                sameObjectsCounter = 0;
                shouldSpeak = true;
            } else {
                sameObjectsCounter++;
                if (sameObjectsCounter >= CHATTER_THRESHOLD) {
                    shouldSpeak = true;
                    sameObjectsCounter = 0;
                }
            }
            
            // Ø§Ù„ØªØ­Ø¯Ø« ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ­Ø¯Ø« Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù„Ø§Ù‹ ÙˆÙ„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù†Ø·Ù‚ Ø­Ø§Ù„ÙŠ
            if (shouldSpeak && autoSpeakCheckbox.checked && !isSpeaking) {
                speakDetections(uniqueObjects);
                lastSpokenObjects = currentObjectsString;
            }

            drawDetections(predictions);
        }
        
        // Ø¯Ø§Ù„Ø© Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø­ÙˆÙ„ Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„Ù…ÙƒØªØ´ÙØ© 
        function drawDetections(predictions) {
            if (canvasElement.width === 0 || canvasElement.height === 0) {
                 setVideoAndCanvasDimensions();
            }

            canvasContext.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            predictions.forEach(prediction => {
                let [x, y, width, height] = prediction.bbox;
                const translatedClass = prediction.translatedClass;

                // --- Ø±Ø³Ù… Ø§Ù„Ø¥Ø·Ø§Ø± (Ø§Ù„Ø¨ÙˆÙƒØ³) ---
                canvasContext.strokeStyle = '#fdbb2d'; 
                canvasContext.lineWidth = 4;
                canvasContext.strokeRect(x, y, width, height);
                
                // --- Ø±Ø³Ù… Ø§Ù„Ù†Øµ (ÙŠØ¬Ø¨ Ø¹ÙƒØ³Ù‡ Ù„ÙŠØ¸Ù‡Ø± Ù…Ù‚Ø±ÙˆØ¡Ù‹Ø§) ---
                canvasContext.save();
                
                // Ù‚Ù„Ø¨ Ø§Ù„Ù…Ø­ÙˆØ± X ÙˆØ¥Ø²Ø§Ø­Ø© Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ Ø¥Ù„Ù‰ ÙŠÙ…ÙŠÙ† Ø§Ù„Ù€ Canvas
                canvasContext.translate(canvasElement.width, 0); 
                canvasContext.scale(-1, 1);
                
                canvasContext.font = 'bold 20px Cairo, Arial';
                const text = `${translatedClass} ${(prediction.score * 100).toFixed(0)}%`;
                const textMetrics = canvasContext.measureText(text);
                const textWidth = textMetrics.width;
                
                // Ø­Ø³Ø§Ø¨ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø¹ÙƒØ³
                const textX = canvasElement.width - x - width + 5; 
                const textY = y + 25; 

                // Ø±Ø³Ù… Ø®Ù„ÙÙŠØ© Ø§Ù„Ù†Øµ (Ù…Ø³ØªØ·ÙŠÙ„)
                canvasContext.fillStyle = '#fdbb2d'; 
                const bgX = canvasElement.width - x - textWidth - 15; 
                const finalBgX = Math.min(bgX, canvasElement.width - 5);
                
                canvasContext.fillRect(finalBgX, y - 28, textWidth + 10, 28);
                
                // Ø±Ø³Ù… Ø§Ù„Ù†Øµ Ù†ÙØ³Ù‡
                canvasContext.fillStyle = '#0f1c4e'; 
                canvasContext.fillText(text, finalBgX + 5, y - 8);
                
                canvasContext.restore();
            });
        }
        
        // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ø¯Ø« Ø¨Ø§Ù„ÙƒØ´Ù (ØªØ£Ø®Ø° Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„ÙØ±ÙŠØ¯Ø© Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©)
        function speakDetections(uniqueObjects) {
            if (!uniqueObjects || uniqueObjects.length === 0) return;
            
            let textToSpeak;
            if (uniqueObjects.length === 1) {
                textToSpeak = `ØªÙ… Ø§ÙƒØªØ´Ø§Ù ${uniqueObjects[0]}`;
            } else {
                const allExceptLast = uniqueObjects.slice(0, -1).join('ØŒ ');
                const lastObject = uniqueObjects[uniqueObjects.length - 1];
                textToSpeak = `ØªÙ… Ø§ÙƒØªØ´Ø§Ù: ${allExceptLast} Ùˆ ${lastObject}`;
            } 
            
            speakText(textToSpeak);
        }
        
        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª 
        function updateStatistics(predictions) {
            detectionCount += 1;
            totalDetections += predictions.length;
            totalDetectionsSpan.textContent = totalDetections;
            
            if (detectionStartTime) {
                const elapsedTime = (Date.now() - detectionStartTime) / 1000;
                const rate = elapsedTime > 0 ? (detectionCount / elapsedTime).toFixed(1) : '0.0';
                detectionRateSpan.textContent = `${rate} Ù…Ø³Ø­Ø©/Ø«Ø§Ù†ÙŠØ©`;
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù„Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù
        async function startDetection() {
            if (isDetecting) return;

            startBtn.disabled = true;
            stopBtn.disabled = false;
            speakBtn.disabled = true;
            
            if (!model) {
                const modelLoaded = await loadModel();
                if (!modelLoaded) {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    return;
                }
            }
            
            const cameraReady = await initCamera();
            if (!cameraReady) {
                 startBtn.disabled = false;
                 return; 
            }

            isDetecting = true;
            
            // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ù…ØªØºÙŠØ±Ø§Øª Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±
            lastSpokenObjects = ''; 
            sameObjectsCounter = 0;
            
            updateStatusDisplay(); // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø¥Ù„Ù‰ "Ø§Ù„ÙƒØ´Ù Ù…Ø³ØªÙ…Ø±"

            detectionStartTime = Date.now();
            detectionCount = 0;
            detectionRateSpan.textContent = '--';
            
            // Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù Ø¹Ù„Ù‰ ÙØªØ±Ø§Øª
            const interval = parseInt(detectionIntervalSelect.value) * 1000;
            detectionInterval = setInterval(detectObjects, interval);
            
            // Ø§Ù„ÙƒØ´Ù Ø§Ù„Ø£ÙˆÙ„ÙŠ ÙÙˆØ±Ø§Ù‹
            detectObjects();
            
            // Ø¥Ø¹Ù„Ø§Ù† Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„
            speakText('Ø¨Ø¯Ø£ Ø§Ù„ÙƒØ´Ù Ø¨Ù†Ø¬Ø§Ø­ØŒ ÙŠØ±Ø¬Ù‰ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§.');
            speakBtn.disabled = false;
        }
        
        // Ø¯Ø§Ù„Ø© Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ´Ù 
        function stopDetection() {
            if (!isDetecting) return;
            
            isDetecting = false;
            clearInterval(detectionInterval);
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            speakBtn.disabled = true;

            updateStatusDisplay(); // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø¥Ù„Ù‰ "ØªÙ… Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù"
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null; 
                stream = null;
            }
            
            // Ø¥ÙŠÙ‚Ø§Ù Ø£ÙŠ ØªØ´ØºÙŠÙ„ ØµÙˆØªÙŠ Ø­Ø§Ù„ÙŠ
            audioPlayer.pause();
            audioPlayer.src = '';
            
            canvasContext.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            window.removeEventListener('resize', setVideoAndCanvasDimensions);

            speakText('ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ´Ù.');
        }
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        window.addEventListener('load', async () => {
            
            await loadModel();
            
            // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù„Ø£Ø²Ø±Ø§Ø±
            startBtn.addEventListener('click', startDetection);
            stopBtn.addEventListener('click', stopDetection);
            
            speakBtn.addEventListener('click', () => {
                if (lastDetections.length > 0) {
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„ÙØ±ÙŠØ¯Ø© Ù„Ù€ ØªÙƒØ±Ø§Ø± Ø§Ù„ÙƒØ´Ù
                    const uniqueObjects = [...new Set(lastDetections.map(p => p.translatedClass))];
                    const allExceptLast = uniqueObjects.slice(0, -1).join('ØŒ ');
                    const lastObject = uniqueObjects[uniqueObjects.length - 1];
                    const objectsText = uniqueObjects.length > 1 
                        ? `${allExceptLast} Ùˆ ${lastObject}`
                        : uniqueObjects[0];

                    speakText(`Ø¢Ø®Ø± Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„ØªÙŠ ØªÙ… Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† Ø¹Ù†Ù‡Ø§ Ù‡ÙŠ: ${objectsText}`);
                } else {
                    speakText('Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£ÙŠ Ø£Ø´ÙŠØ§Ø¡ ÙÙŠ Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ.');
                }
            });
            
            // ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯
            volumeControl.addEventListener('change', () => {
                audioPlayer.volume = parseFloat(volumeControl.value);
            });
            
            // ØªØ­Ø¯ÙŠØ« ÙØªØ±Ø© Ø§Ù„ÙƒØ´Ù Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
            detectionIntervalSelect.addEventListener('change', () => {
                const newValue = detectionIntervalSelect.value;
                if (isDetecting) {
                    clearInterval(detectionInterval);
                    const interval = parseInt(newValue) * 1000;
                    detectionInterval = setInterval(detectObjects, interval);
                    speakText(`ØªÙ… ØªØºÙŠÙŠØ± ÙØªØ±Ø© Ø§Ù„ÙƒØ´Ù Ø¥Ù„Ù‰ ${newValue} Ø«ÙˆØ§Ù†ÙŠ.`);
                } else {
                    speakText(`ÙØªØ±Ø© Ø§Ù„ÙƒØ´Ù Ù‡ÙŠ ${newValue} Ø«ÙˆØ§Ù†ÙŠ.`);
                }
            });
            
            confidenceThresholdSelect.addEventListener('change', () => {
                speakText(`ØªÙ… ØªØºÙŠÙŠØ± Ø­Ø¯ Ø§Ù„Ø«Ù‚Ø© Ø¥Ù„Ù‰ ${confidenceThresholdSelect.value * 100} Ø¨Ø§Ù„Ù…Ø¦Ø©.`);
            });
        });
    </script>
</body>
</html>

